<!doctype html>
<html lang="zh-CN">
<head>

    <meta charset="utf-8">
    <meta name="generator" content="Hugo 0.57.2" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Form和ModelForm组件 | 王一帆的博客</title>
    <meta property="og:title" content="Form和ModelForm组件 - 王一帆的博客">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content="2019-03-29T20:20:02&#43;08:00">
        
        
    <meta property="article:modified_time" content="2019-03-29T20:20:02&#43;08:00">
        
    <meta name="Keywords" content="Python,Django,GoLang,博客,项目管理,公众号,小程序">
    <meta name="description" content="Form和ModelForm组件">
        
    <meta name="author" content="王一帆">
    <meta property="og:url" content="http://yifan-x.github.io/post/django-form%E5%92%8Cmodelform%E7%BB%84%E4%BB%B6/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href="/css/normalize.css">
    
        <link rel="stylesheet" href="/css/prism.css">
    
    <link rel="stylesheet" href="/css/style.css">
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    


    
    
</head>

<body>
<header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="http://yifan-x.github.io">
                        王一帆的博客
                    </a>
                
                <p class="description">专注于Python、Go语言(GoLang)</p>
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="current" href="http://yifan-x.github.io">首页</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>


<div id="body">
        
        
    <div class="container">
        <div class="col-group">

            <div class="col-8" id="main">
                <div class="res-cons">
                    <article class="post">
                        <header>
                            <h1 class="post-title">Form和ModelForm组件</h1>
                        </header>
                        <date class="post-meta meta-date">
                            2019年3月29日
                        </date>
                        
                        
                        
                        <div class="post-content">
                            

<h2 id="一-form介绍">一： Form介绍</h2>

<p>　　</p>

<pre><code>我们之前在HTML页面中利用form表单向后端提交数据时，都会写一些获取用户输入的标签并且用form标签把它们包起来。

与此同时我们在好多场景下都需要对用户的输入做校验，比如校验用户是否输入，输入的长度和格式等正不正确。如果用户输入的内容有错误就需要在页面上相应的位置显示对应的错误信息。

Django form组件就实现了上面所述的功能。

总结一下，其实form组件的主要功能如下:

        生成页面可用的HTML标签

        对用户提交的数据进行校验

        保留上次输入内容
</code></pre>

<p><br/></p>

<h3 id="1-1-普通方式手写注册功能">1.1：普通方式手写注册功能</h3>

<h4 id="views-py">views.py</h4>

<pre><code class="language-python"># 注册
def register(request):
    error_msg = &quot;&quot;
    if request.method == &quot;POST&quot;:
        username = request.POST.get(&quot;name&quot;)
        pwd = request.POST.get(&quot;pwd&quot;)
        # 对注册信息做校验
        if len(username) &lt; 6:
            # 用户长度小于6位
            error_msg = &quot;用户名长度不能小于6位&quot;
        else:
            # 将用户名和密码存到数据库
            return HttpResponse(&quot;注册成功&quot;)
    return render(request, &quot;register.html&quot;, {&quot;error_msg&quot;: error_msg})
</code></pre>

<h4 id="login-html">login.html</h4>

<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;注册页面&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;form action=&quot;/reg/&quot; method=&quot;post&quot;&gt;
    {% csrf_token %}
    &lt;p&gt;
        用户名:
        &lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;
    &lt;/p&gt;
    &lt;p&gt;
        密码：
        &lt;input type=&quot;password&quot; name=&quot;pwd&quot;&gt;
    &lt;/p&gt;
    &lt;p&gt;
        &lt;input type=&quot;submit&quot; value=&quot;注册&quot;&gt;
        &lt;p style=&quot;color: red&quot;&gt;{{ error_msg }}&lt;/p&gt;
    &lt;/p&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p><br/></p>

<h3 id="1-2-使用form组件实现注册功能">1.2：使用form组件实现注册功能</h3>

<h4 id="views-py-1">views.py</h4>

<p>先定义好一个RegForm类：</p>

<pre><code class="language-python">from django import forms

# 按照Django form组件的要求自己写一个类
class RegForm(forms.Form):
    name = forms.CharField(label=&quot;用户名&quot;)  
# form字段的名称写的是什么，那么前端生成input标签的时候，input标签的name属性的值就是什么
    pwd = forms.CharField(label=&quot;密码&quot;)
</code></pre>

<p>再写一个视图函数：</p>

<pre><code class="language-python"># 使用form组件实现注册方式
def register2(request):
    form_obj = RegForm()
    if request.method == &quot;POST&quot;:
# 实例化form对象的时候，把post提交过来的数据直接传进去
        form_obj = RegForm(data=request.POST)  
# 既然传过来的input标签的name属性值和form类对应的字段名是一样的，所以接过来后，form就取出对应的form字段名相同的数据进行form校验

        # 调用form_obj校验数据的方法
        if form_obj.is_valid():
            return HttpResponse(&quot;注册成功&quot;)
    return render(request, &quot;register2.html&quot;, {&quot;form_obj&quot;: form_obj})
</code></pre>

<h4 id="login2-html">　　　　login2.html</h4>

<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;注册2&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;form action=&quot;/reg2/&quot; method=&quot;post&quot; novalidate autocomplete=&quot;off&quot;&gt;  
// novalidate 告诉前端form表单，不要对输入的内容做校验
        {% csrf_token %}
// {{ form_obj.as_p }}  直接写个这个，下面的用户名和密码的标签不自己写，你看看效果
        
        &lt;div&gt;
            &lt;label for=&quot;{{ form_obj.name.id_for_label }}&quot;&gt;{{ form_obj.name.label }}&lt;/label&gt;
            {{ form_obj.name }} {{ form_obj.name.errors.0 }}  

# errors是这个字段所有的错误，我就用其中一个错误提示就可以了，再错了再提示，并且不是给你生成ul标签了，单纯的是错误文本
            
           {{ form_obj.errors }} 
# 这是全局的所有错误，找对应字段的错误，就要form_obj.字段名
        &lt;/div&gt;
      
        
        &lt;div&gt;
            &lt;label for=&quot;{{ form_obj.pwd.id_for_label }}&quot;&gt;{{ form_obj.pwd.label }}&lt;/label&gt;
            {{ form_obj.pwd }} {{ form_obj.pwd.errors.0 }}
        &lt;/div&gt;
        &lt;div&gt;
            &lt;input type=&quot;submit&quot; class=&quot;btn btn-success&quot; value=&quot;注册&quot;&gt;
        &lt;/div&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p><br/></p>

<p>　　</p>

<pre><code>看网页效果发现 也验证了form的功能：
前端页面是form类的对象生成的                       --&gt; 生成HTML标签功能
当用户名和密码输入为空或输错之后 页面都会提示        --&gt; 用户提交校验功能
当用户输错之后 再次输入 上次的内容还保留在input框    --&gt; 保留上次输入内容
</code></pre>

<p><br/></p>

<p><br/></p>

<h2 id="二-form常用字段与插件">二： Form常用字段与插件</h2>

<p>创建Form类时，主要涉及到 【字段】 和 【插件】，字段用于对用户请求数据的验证，插件用于自动生成HTML;</p>

<p><br/></p>

<h3 id="2-1-initial">　　2.1：initial</h3>

<p>初始值，input框里面的初始值。</p>

<pre><code class="language-python">class LoginForm(forms.Form):
    username = forms.CharField(  
        min_length=8,
        label=&quot;用户名&quot;,
        initial=&quot;张三&quot;  # 设置默认值
    )
    pwd = forms.CharField(min_length=6, label=&quot;密码&quot;)
</code></pre>

<p><br/></p>

<h3 id="2-2-error-messages">　　2.2：error_messages</h3>

<p>重写错误信息。</p>

<pre><code class="language-python">class LoginForm(forms.Form):
    username = forms.CharField(
        min_length=8,
        label=&quot;用户名&quot;,
        initial=&quot;张三&quot;,
        error_messages={
            &quot;required&quot;: &quot;不能为空&quot;,
            &quot;invalid&quot;: &quot;格式错误&quot;,
            &quot;min_length&quot;: &quot;用户名最短8位&quot;
        }
    )
    pwd = forms.CharField(min_length=6, label=&quot;密码&quot;)
</code></pre>

<p><br/></p>

<h3 id="2-3-password">　　2.3：password</h3>

<pre><code class="language-python">class LoginForm(forms.Form):
    ...
    pwd = forms.CharField(
        min_length=6,
        label=&quot;密码&quot;,
        widget=forms.widgets.PasswordInput(attrs={'class': 'c1'}, render_value=True) 
# 这个密码字段和其他字段不一样，默认在前端输入数据错误的时候，点击提交之后，默认是不保存的原来数据的，但是可以通过这个render_value=True让这个字段在前端保留用户输入的数据
    )
</code></pre>

<p><br/></p>

<h3 id="2-4-radioselect">　　2.4：radioSelect</h3>

<p>单radio值为字符串</p>

<pre><code class="language-python">class LoginForm(forms.Form):
    username = forms.CharField(  #其他选择框或者输入框，基本都是在这个CharField的基础上通过插件来搞的
        min_length=8,
        label=&quot;用户名&quot;,
        initial=&quot;张三&quot;,
        error_messages={
            &quot;required&quot;: &quot;不能为空&quot;,
            &quot;invalid&quot;: &quot;格式错误&quot;,
            &quot;min_length&quot;: &quot;用户名最短8位&quot;
        }
    )
    pwd = forms.CharField(min_length=6, label=&quot;密码&quot;)
    gender = forms.fields.ChoiceField(
        choices=((1, &quot;男&quot;), (2, &quot;女&quot;), (3, &quot;保密&quot;)),
        label=&quot;性别&quot;,
        initial=3,
        widget=forms.widgets.RadioSelect()
    )
</code></pre>

<p><br/></p>

<h3 id="2-5-单选select">　　2.5：单选Select</h3>

<pre><code class="language-python">class LoginForm(forms.Form):
    ...
    hobby = forms.fields.ChoiceField(
        choices=((1, &quot;篮球&quot;), (2, &quot;足球&quot;), (3, &quot;双色球&quot;), ),
        label=&quot;爱好&quot;,
        initial=3,
        widget=forms.widgets.Select()
    )
</code></pre>

<p><br/></p>

<h3 id="2-6-多选select">　　2.6：多选Select</h3>

<pre><code class="language-python">class LoginForm(forms.Form):
    ...
    hobby = forms.fields.MultipleChoiceField(
        choices=((1, &quot;篮球&quot;), (2, &quot;足球&quot;), (3, &quot;双色球&quot;), ),
        label=&quot;爱好&quot;,
        initial=[1, 3],
        widget=forms.widgets.SelectMultiple()
    )
</code></pre>

<p><br/></p>

<h3 id="2-7-单选checkbox">　　2.7：单选checkbox</h3>

<pre><code class="language-python">class LoginForm(forms.Form):
    ...
    keep = forms.fields.ChoiceField(
        label=&quot;是否记住密码&quot;,
        initial=&quot;checked&quot;,
        widget=forms.widgets.CheckboxInput()
    )
</code></pre>

<p><br/></p>

<h3 id="2-8-多选checkbox">　　2.8：多选checkbox</h3>

<pre><code class="language-python">class LoginForm(forms.Form):
    ...
    hobby = forms.fields.MultipleChoiceField(
        choices=((1, &quot;篮球&quot;), (2, &quot;足球&quot;), (3, &quot;双色球&quot;),),
        label=&quot;爱好&quot;,
        initial=[1, 3],
        widget=forms.widgets.CheckboxSelectMultiple()
    )
</code></pre>

<p><br/></p>

<h3 id="2-9-date类型">　　2.9：date类型</h3>

<pre><code class="language-python">from django import forms
from django.forms import widgets
class BookForm(forms.Form):
    date = forms.DateField(widget=widgets.TextInput(attrs={'type':'date'}))  
    # 必须指定type，不然不能渲染成选择时间的input框
</code></pre>

<p><br/></p>

<h3 id="2-10-choice字段注意事项">　　2.10：choice字段注意事项</h3>

<p>在使用选择标签时，需要注意choices的选项可以配置从数据库中获取，但是由于是静态字段 获取的值无法实时更新，需要重写构造方法从而实现choice实时更新。</p>

<p><strong>方式一：</strong></p>

<pre><code class="language-python">from django.forms import Form
from django.forms import widgets
from django.forms import fields

 
class MyForm(Form):
 
    user = fields.ChoiceField(
        # choices=((1, '上海'), (2, '北京'),),
        initial=2,
        widget=widgets.Select
    )
 
    def __init__(self, *args, **kwargs):
        super(MyForm,self).__init__(*args, **kwargs)
        # self.fields['user'].choices = ((1, '上海'), (2, '北京'),)
        # 或
        self.fields['user'].choices = models.Classes.objects.all().values_list('id','caption')
</code></pre>

<p><strong>方式二：</strong></p>

<pre><code class="language-python">from django import forms
from django.forms import fields
from django.forms import models as form_model

 
class FInfo(forms.Form):
　　
    authors = forms.ModelMultipleChoiceField(queryset=models.NNewType.objects.all())  # 多选
    #或者下面这种方式，通过forms里面的models中提供的方法也是一样的。
    authors = form_model.ModelMultipleChoiceField(queryset=models.NNewType.objects.all())  # 多选
    # authors = form_model.ModelChoiceField(queryset=models.NNewType.objects.all())  # 单选
</code></pre>

<p><br/></p>

<p><br/></p>

<h2 id="三-form所有内置字段">三： Form所有内置字段</h2>

<p><strong>内置字段：</strong></p>

<pre><code class="language-python">Field
    required=True,               是否允许为空
    widget=None,                 HTML插件
    label=None,                  用于生成Label标签或显示内容
    initial=None,                初始值
    help_text='',                帮助信息(在标签旁边显示)
    error_messages=None,         错误信息 {'required': '不能为空', 'invalid': '格式错误'}
    validators=[],               自定义验证规则
    localize=False,              是否支持本地化
    disabled=False,              是否可以编辑
    label_suffix=None            Label内容后缀
 
 
CharField(Field)
    max_length=None,             最大长度
    min_length=None,             最小长度
    strip=True                   是否移除用户输入空白
 
IntegerField(Field)
    max_value=None,              最大值
    min_value=None,              最小值
 
FloatField(IntegerField)
    ...
 
DecimalField(IntegerField)
    max_value=None,              最大值
    min_value=None,              最小值
    max_digits=None,             总长度
    decimal_places=None,         小数位长度
 
BaseTemporalField(Field)
    input_formats=None          时间格式化   
 
DateField(BaseTemporalField)    格式：2015-09-01
TimeField(BaseTemporalField)    格式：11:12
DateTimeField(BaseTemporalField)格式：2015-09-01 11:12
 
DurationField(Field)            时间间隔：%d %H:%M:%S.%f
    ...
 
RegexField(CharField)
    regex,                      自定制正则表达式
    max_length=None,            最大长度
    min_length=None,            最小长度
    error_message=None,         忽略，错误信息使用 error_messages={'invalid': '...'}
 
EmailField(CharField)      
    ...
 
FileField(Field)
    allow_empty_file=False     是否允许空文件
 
ImageField(FileField)      
    ...
    注：需要PIL模块，pip3 install Pillow
    以上两个字典使用时，需要注意两点：
        - form表单中 enctype=&quot;multipart/form-data&quot;
        - view函数中 obj = MyForm(request.POST, request.FILES)
 
URLField(Field)
    ...
 
 
BooleanField(Field)  
    ...
 
NullBooleanField(BooleanField)
    ...
 
ChoiceField(Field)
    ...
    choices=(),                选项，如：choices = ((0,'上海'),(1,'北京'),)
    required=True,             是否必填
    widget=None,               插件，默认select插件
    label=None,                Label内容
    initial=None,              初始值
    help_text='',              帮助提示
 
 
ModelChoiceField(ChoiceField)
    ...                        django.forms.models.ModelChoiceField
    queryset,                  # 查询数据库中的数据
    empty_label=&quot;---------&quot;,   # 默认空显示内容
    to_field_name=None,        # HTML中value的值对应的字段
    limit_choices_to=None      # ModelForm中对queryset二次筛选
     
ModelMultipleChoiceField(ModelChoiceField)
    ...                        django.forms.models.ModelMultipleChoiceField
 
 
     
TypedChoiceField(ChoiceField)
    coerce = lambda val: val   对选中的值进行一次转换
    empty_value= ''            空值的默认值
 
MultipleChoiceField(ChoiceField)
    ...
 
TypedMultipleChoiceField(MultipleChoiceField)
    coerce = lambda val: val   对选中的每一个值进行一次转换
    empty_value= ''            空值的默认值
 
ComboField(Field)
    fields=()                  使用多个验证，如下：即验证最大长度20，又验证邮箱格式
                               fields.ComboField(fields=[fields.CharField(max_length=20), fields.EmailField(),])
 
MultiValueField(Field)
    PS: 抽象类，子类中可以实现聚合多个字典去匹配一个值，要配合MultiWidget使用
 
SplitDateTimeField(MultiValueField)
    input_date_formats=None,   格式列表：['%Y--%m--%d', '%m%d/%Y', '%m/%d/%y']
    input_time_formats=None    格式列表：['%H:%M:%S', '%H:%M:%S.%f', '%H:%M']
 
FilePathField(ChoiceField)     文件选项，目录下文件显示在页面中
    path,                      文件夹路径
    match=None,                正则匹配
    recursive=False,           递归下面的文件夹
    allow_files=True,          允许文件
    allow_folders=False,       允许文件夹
    required=True,
    widget=None,
    label=None,
    initial=None,
    help_text=''
 
GenericIPAddressField
    protocol='both',           both,ipv4,ipv6支持的IP格式
    unpack_ipv4=False          解析ipv4地址，如果是::ffff:192.0.2.1时候，可解析为192.0.2.1， PS：protocol必须为both才能启用
 
SlugField(CharField)           数字，字母，下划线，减号（连字符）
    ...
 
UUIDField(CharField)           uuid类型
复制代码
</code></pre>

<p><br/></p>

<p><br/></p>

<h2 id="四-字段校验">四 ：字段校验</h2>

<h3 id="4-1-regexvalidator验证器">　　4.1：RegexValidator验证器</h3>

<pre><code class="language-python">from django.forms import Form
from django.forms import widgets
from django.forms import fields
from django.core.validators import RegexValidator
 
class MyForm(Form):
    user = fields.CharField(
        validators=[RegexValidator(r'^[0-9]+$', '请输入数字'), RegexValidator(r'^159[0-9]+$', '数字必须以159开头')],
    )
</code></pre>

<p><br/></p>

<h3 id="4-2-自定义验证函数">　　4.2：自定义验证函数</h3>

<pre><code class="language-python">import re
from django.forms import Form
from django.forms import widgets
from django.forms import fields
from django.core.exceptions import ValidationError
 
 
# 自定义验证规则
def mobile_validate(value):
    mobile_re = re.compile(r'^(13[0-9]|15[012356789]|17[678]|18[0-9]|14[57])[0-9]{8}$')
    if not mobile_re.match(value):
        raise ValidationError('手机号码格式错误')  
        # 自定义验证规则的时候，如果不符合你的规则，需要自己发起错误
 
 
class PublishForm(Form):
 
 
    title = fields.CharField(
        max_length=20,
        min_length=5,
        error_messages={'required': '标题不能为空',
                        'min_length': '标题最少为5个字符',
                        'max_length': '标题最多为20个字符'},
        widget=widgets.TextInput(attrs={'class': &quot;form-control&quot;,
                                        'placeholder': '标题5-20个字符'}))
 
 
    # 使用自定义验证规则
    phone = fields.CharField(
        validators=[mobile_validate, ],
        error_messages={'required': '手机不能为空'},
        widget=widgets.TextInput(attrs={'class': &quot;form-control&quot;,
                                        'placeholder': u'手机号码'}))
 
    email = fields.EmailField(
        required=False,
        error_messages={'required': u'邮箱不能为空','invalid': u'邮箱格式错误'},
        widget=widgets.TextInput(attrs={'class': &quot;form-control&quot;, 'placeholder': u'邮箱'}))
</code></pre>

<p><br/></p>

<p><br/></p>

<h2 id="五-hook钩子方法">五： Hook钩子方法</h2>

<p><strong>除了上面两种方式，我们还可以在Form类中定义钩子函数，来实现自定义的验证功能。</strong></p>

<h3 id="5-1-局部钩子">　　5.1：局部钩子</h3>

<p>我们在Fom类中定义 clean_字段名() 方法，就能够实现对特定字段进行校验。</p>

<p>举个例子：</p>

<pre><code class="language-python">class LoginForm(forms.Form):
    username = forms.CharField(
        min_length=8,
        label=&quot;用户名&quot;,
        initial=&quot;张三&quot;,
        error_messages={
            &quot;required&quot;: &quot;不能为空&quot;,
            &quot;invalid&quot;: &quot;格式错误&quot;,
            &quot;min_length&quot;: &quot;用户名最短8位&quot;
        },
        widget=forms.widgets.TextInput(attrs={&quot;class&quot;: &quot;form-control&quot;})
    )
    ...
    # 定义局部钩子，用来校验username字段,之前的校验股则还在，给你提供了一个添加一些校验功能的钩子
    def clean_username(self):
        value = self.cleaned_data.get(&quot;username&quot;)
        if &quot;666&quot; in value:
            raise ValidationError(&quot;光喊666是不行的&quot;)
        else:
            return value
</code></pre>

<p><br/></p>

<h3 id="5-2-全局钩子">　　5.2：全局钩子</h3>

<p>我们在Fom类中定义 clean() 方法，就能够实现对字段进行全局校验，字段全部验证完，局部钩子也全部执行完之后，执行这个全局钩子校验。</p>

<pre><code class="language-python">class LoginForm(forms.Form):
    ...
    password = forms.CharField(
        min_length=6,
        label=&quot;密码&quot;,
        widget=forms.widgets.PasswordInput(attrs={'class': 'form-control'}, render_value=True)
    )
    re_password = forms.CharField(
        min_length=6,
        label=&quot;确认密码&quot;,
        widget=forms.widgets.PasswordInput(attrs={'class': 'form-control'}, render_value=True)
    )
    ...
# 定义全局的钩子，用来校验密码和确认密码字段是否相同，执行全局钩子的时候，cleaned_data里面肯定是有了通过前面验证的所有数据
    def clean(self):
        password_value = self.cleaned_data.get('password')
        re_password_value = self.cleaned_data.get('re_password')
        if password_value == re_password_value:
            return self.cleaned_data #全局钩子要返回所有的数据
        else:
            self.add_error('re_password', '两次密码不一致') 
# 在re_password这个字段的错误列表中加上一个错误，并且clean_data里面会自动清除这个re_password的值，所以打印clean_data的时候会看不到它
            raise ValidationError('两次密码不一致')
</code></pre>

<p><br/></p>

<p><br/></p>

<h2 id="六-进阶补充">六： 进阶补充</h2>

<h3 id="6-1-应用bootstrap样式">　　6.1：应用Bootstrap样式</h3>

<p>Django form应用Bootstrap样式简单示例：</p>

<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=edge&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;/static/bootstrap/css/bootstrap.min.css&quot;&gt;
  &lt;title&gt;login&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class=&quot;container&quot;&gt;
  &lt;div class=&quot;row&quot;&gt;
    &lt;form action=&quot;/login2/&quot; method=&quot;post&quot; novalidate class=&quot;form-horizontal&quot;&gt;
      {% csrf_token %}
      &lt;div class=&quot;form-group&quot;&gt;
        &lt;label for=&quot;{{ form_obj.username.id_for_label }}&quot;
               class=&quot;col-md-2 control-label&quot;&gt;{{ form_obj.username.label }}&lt;/label&gt;
        &lt;div class=&quot;col-md-10&quot;&gt;
          {{ form_obj.username }}
          &lt;span class=&quot;help-block&quot;&gt;{{ form_obj.username.errors.0 }}&lt;/span&gt;
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;form-group&quot;&gt;
        &lt;label for=&quot;{{ form_obj.pwd.id_for_label }}&quot; class=&quot;col-md-2 control-label&quot;&gt;{{ form_obj.pwd.label }}&lt;/label&gt;
        &lt;div class=&quot;col-md-10&quot;&gt;
          {{ form_obj.pwd }}
          &lt;span class=&quot;help-block&quot;&gt;{{ form_obj.pwd.errors.0 }}&lt;/span&gt;
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;form-group&quot;&gt;
      &lt;label class=&quot;col-md-2 control-label&quot;&gt;{{ form_obj.gender.label }}&lt;/label&gt;
        &lt;div class=&quot;col-md-10&quot;&gt;
          &lt;div class=&quot;radio&quot;&gt;
            {% for radio in form_obj.gender %}
              &lt;label for=&quot;{{ radio.id_for_label }}&quot;&gt;
                {{ radio.tag }}{{ radio.choice_label }}
              &lt;/label&gt;
            {% endfor %}
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;form-group&quot;&gt;
        &lt;div class=&quot;col-md-offset-2 col-md-10&quot;&gt;
          &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;注册&lt;/button&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/form&gt;
  &lt;/div&gt;
&lt;/div&gt;

&lt;script src=&quot;/static/jquery-3.2.1.min.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;/static/bootstrap/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p><br/></p>

<h3 id="6-2-批量添加样式">　　6.2：批量添加样式</h3>

<p>可通过重写form类的init方法来实现。</p>

<pre><code class="language-python">class LoginForm(forms.Form):
    username = forms.CharField(
        min_length=8,
        label=&quot;用户名&quot;,
        initial=&quot;张三&quot;,
        error_messages={
            &quot;required&quot;: &quot;不能为空&quot;,
            &quot;invalid&quot;: &quot;格式错误&quot;,
            &quot;min_length&quot;: &quot;用户名最短8位&quot;
        }
    ...

    def __init__(self, *args, **kwargs):
        super(LoginForm, self).__init__(*args, **kwargs)
        for field in iter(self.fields):
            self.fields[field].widget.attrs.update({
                'class': 'form-control'
            })
</code></pre>

<p><br/></p>

<p><br/></p>

<h2 id="七-modelform">七： ModelForm</h2>

<pre><code>通常在Django项目中，我们编写的大部分都是与Django 的模型紧密映射的表单。 举个例子，你也许会有个Book 模型，并且你还想创建一个form表单用来添加和编辑书籍信息到这个模型中。 在这种情况下，在form表单中定义字段将是冗余的，因为我们已经在模型中定义了那些字段。

基于这个原因，Django 提供一个辅助类来让我们可以从Django 的模型创建Form，这就是ModelForm。
</code></pre>

<h3 id="7-1-modelform定义">　　7.1：modelForm定义</h3>

<p>form与model的终极结合。</p>

<pre><code class="language-python">class BookForm(forms.ModelForm):

    class Meta:
        model = models.Book
        fields = &quot;__all__&quot;
        labels = {
            &quot;title&quot;: &quot;书名&quot;,
            &quot;price&quot;: &quot;价格&quot;
        }
        widgets = {
            &quot;password&quot;: forms.widgets.PasswordInput(attrs={&quot;class&quot;: &quot;c1&quot;}),
        }
</code></pre>

<p><br/></p>

<h3 id="7-2-class-meta下常用参数">　　7.2：class Meta下常用参数：</h3>

<pre><code class="language-python">model = models.Book  # 对应的Model中的类
fields = &quot;__all__&quot;  # 字段，如果是__all__,就是表示列出所有的字段
exclude = None  # 排除的字段
labels = None  # 提示信息
help_texts = None  # 帮助提示信息
widgets = None  # 自定义插件
error_messages = None  # 自定义错误信息
</code></pre>

<p><br/></p>

<h3 id="7-3-modelform的验证">　　7.3：ModelForm的验证</h3>

<pre><code>与普通的Form表单验证类型类似，ModelForm表单的验证在调用is_valid() 或访问errors 属性时隐式调用。

我们可以像使用Form类一样自定义局部钩子方法和全局钩子方法来实现自定义的校验规则。

如果我们不重写具体字段并设置validators属性的化，ModelForm是按照模型中字段的validators来校验的。
</code></pre>

<p><br/></p>

<h3 id="7-4-save-方法">　　7.4：save()方法</h3>

<pre><code>每个ModelForm还具有一个save()方法。 这个方法根据表单绑定的数据创建并保存数据库对象。 ModelForm的子类可以接受现有的模型实例作为关键字参数instance；如果提供此功能，则save()将更新该实例。 如果没有提供，save() 将创建模型的一个新实例：
</code></pre>

<pre><code class="language-python">&gt;&gt;&gt; from myapp.models import Book
&gt;&gt;&gt; from myapp.forms import BookForm

# 根据POST数据创建一个新的form对象
&gt;&gt;&gt; form_obj = BookForm(request.POST)

# 创建书籍对象
&gt;&gt;&gt; new_ book = form_obj.save()

# 基于一个书籍对象创建form对象
&gt;&gt;&gt; edit_obj = Book.objects.get(id=1)
# 使用POST提交的数据更新书籍对象
&gt;&gt;&gt; form_obj = BookForm(request.POST, instance=edit_obj)
&gt;&gt;&gt; form_obj.save()
</code></pre>

<p>之前我们通过form组件来保存书籍表数据的时候的写法：</p>

<pre><code class="language-python">def index(request):
    if request.method == 'GET':
        form_obj = BookForm()

        return render(request,'index.html',{'form_obj':form_obj})

    else:
        form_obj = BookForm(request.POST)
        if form_obj.is_valid():
            # authors_obj = form_obj.cleaned_data.pop('authors')
            # new_book_obj = models.Book.objects.create(**form_obj.cleaned_data)
            # new_book_obj.authors.add(*authors_obj)
            form_obj.save()  
# 因为我们再Meta中指定了是哪张表，所以它会自动识别，不管是外键还是多对多等，都会自行处理保存，它完成的就是上面三句话做的事情，并且还有就是如果你验证的数据比你后端数据表中的字段多，那么他自会自动剔除多余的不需要保存的字段，比如那个重复确认密码就不要保存
            return redirect('show')

        else:
            print(form_obj.errors)
            return render(request,'index.html',{'form_obj':form_obj})
</code></pre>

<p><br/></p>

<h3 id="7-5-示例-图书管理系统页面">7.5：示例：图书管理系统页面</h3>

<h4 id="7-5-1-以前写法">7.5.1：以前写法</h4>

<h5 id="html">html：</h5>

<pre><code class="language-html">{% load static %}
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;{% static 'bootstrap-3.3.0-dist/dist/css/bootstrap.min.css' %}&quot;&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h1&gt;编辑页面&lt;/h1&gt;
&lt;div class=&quot;container-fluid&quot;&gt;
    &lt;div class=&quot;row&quot;&gt;
        &lt;div class=&quot;col-md-6 col-md-offset-3&quot;&gt;
            &lt;form action=&quot;&quot;&gt;
                &lt;div class=&quot;form-group&quot;&gt;
                    &lt;label for=&quot;title&quot;&gt;书名&lt;/label&gt;
                    &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;title&quot; placeholder=&quot;title&quot; value=&quot;{{ book_obj.title }}&quot;&gt;

                &lt;/div&gt;
                &lt;div class=&quot;form-group&quot;&gt;
                    &lt;label for=&quot;publishDate&quot;&gt;出版日期&lt;/label&gt;
                    &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;publishDate&quot; placeholder=&quot;publishDate&quot; value=&quot;{{ book_obj.publishDate|date:'Y-m-d' }}&quot;&gt;

                &lt;/div&gt;
                &lt;div class=&quot;form-group&quot;&gt;
                    &lt;label for=&quot;price&quot;&gt;价格&lt;/label&gt;
                    &lt;input type=&quot;number&quot; class=&quot;form-control&quot; id=&quot;price&quot; placeholder=&quot;price&quot; value=&quot;{{ book_obj.price }}&quot;&gt;

                &lt;/div&gt;
                &lt;div class=&quot;form-group&quot;&gt;
                    &lt;label for=&quot;publish&quot;&gt;书名&lt;/label&gt;
                    &lt;select name=&quot;publish&quot; id=&quot;publish&quot; class=&quot;form-control&quot;&gt;
                        {% for publish in all_publish %}
                                {% if publish == book_obj.publish %}
                                    &lt;option value=&quot;{{ publish.id }}&quot; selected&gt;{{ publish.name }}&lt;/option&gt;
                                {% else %}
                                    &lt;option value=&quot;{{ publish.id }}&quot;&gt;{{ publish.name }}&lt;/option&gt;
                                {% endif %}
                        {% endfor %}

                    &lt;/select&gt;

                &lt;/div&gt;
                &lt;div class=&quot;form-group&quot;&gt;
                    &lt;label for=&quot;authors&quot;&gt;书名&lt;/label&gt;
                    &lt;select name=&quot;authors&quot; id=&quot;authors&quot; multiple class=&quot;form-control&quot;&gt;
                        {% for author in all_authors %}
                            {% if author in book_obj.authors.all %}
                                &lt;option value=&quot;{{ author.id }}&quot; selected&gt;{{ author.name }}&lt;/option&gt;
                            {% else %}
                                 &lt;option value=&quot;{{ author.id }}&quot; &gt;{{ author.name }}&lt;/option&gt;
                            {% endif %}
                        {% endfor %}

                    &lt;/select&gt;

                &lt;/div&gt;
            &lt;/form&gt;

        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;


&lt;/body&gt;
&lt;script src=&quot;{% static 'bootstrap-3.3.0-dist/dist/jQuery/jquery-3.1.1.js' %}&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;{% static 'bootstrap-3.3.0-dist/dist/js/bootstrap.min.js' %}&quot;&gt;&lt;/script&gt;
&lt;/html&gt;
</code></pre>

<h5 id="views-py-2">views.py：</h5>

<pre><code class="language-python">def edit_book(request,n):

    book_obj = models.Book.objects.filter(pk=n).first()
    if request.method == 'GET':
        all_authors = models.Author.objects.all() #
        all_publish = models.Publish.objects.all()

        return render(request,'edit_book.html',{'book_obj':book_obj,'all_authors':all_authors,'all_publish':all_publish})
</code></pre>

<h4 id="7-5-2-使用modelform">7.5.2：使用modelform</h4>

<h5 id="html-1">html：</h5>

<pre><code class="language-html">{% load static %}
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;{% static 'bootstrap-3.3.0-dist/dist/css/bootstrap.min.css' %}&quot;&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h1&gt;编辑页面&lt;/h1&gt;
&lt;div class=&quot;container-fluid&quot;&gt;
    &lt;div class=&quot;row&quot;&gt;
        &lt;div class=&quot;col-md-6 col-md-offset-3&quot;&gt;
            &lt;form action=&quot;{% url 'edit_book' n %}&quot; novalidate method=&quot;post&quot;&gt;
                {% csrf_token %}
                {% for field in form %}
                    &lt;div class=&quot;form-group&quot;&gt;
                        &lt;label for=&quot;{{ field.id_for_label }}&quot;&gt;{{ field.label }}&lt;/label&gt;
                        {{ field }}
                        &lt;span class=&quot;text-danger&quot;&gt;{{ field.errors.0 }}&lt;/span&gt;
                    &lt;/div&gt;
                {% endfor %}

                &lt;div class=&quot;form-group&quot;&gt;
                    &lt;input type=&quot;submit&quot; class=&quot;btn btn-primary pull-right&quot;&gt;
                &lt;/div&gt;

            &lt;/form&gt;

        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;


&lt;/body&gt;
&lt;script src=&quot;{% static 'bootstrap-3.3.0-dist/dist/jQuery/jquery-3.1.1.js' %}&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;{% static 'bootstrap-3.3.0-dist/dist/js/bootstrap.min.js' %}&quot;&gt;&lt;/script&gt;
&lt;/html&gt;
</code></pre>

<h5 id="views-py-3">views.py：</h5>

<pre><code class="language-python">def edit_book(request,n):

    book_obj = models.Book.objects.filter(pk=n).first()
    if request.method == 'GET':
        # all_authors = models.Author.objects.all() #
        # all_publish = models.Publish.objects.all()

        form = BookForm(instance=book_obj)

        return render(request,'edit_book.html',{'form':form,'n':n}) #传递的这个n参数是给form表单提交数据的是的action的url用的，因为它需要一个参数来识别是更新的哪条记录

    else:
        form = BookForm(request.POST,instance=book_obj) #必须指定instance，不然我们调用save方法的是又变成了添加操作
        if form.is_valid():
            form.save()
            return redirect('show')
        else:
            return render(request,'edit_book.html',{'form':form,'n':n})
</code></pre>

<p><br/></p>

<p><br/></p>

<h2 id="八-modelform补充">八：ModelForm补充</h2>

<pre><code>这是一个神奇的组件，通过名字我们可以看出来，这个组件的功能就是把model和form组合起来，先来一个简单的例子来看一下这个东西怎么用：比如我们的数据库中有这样一张学生表，字段有姓名，年龄，爱好，邮箱，电话，住址，注册时间等等一大堆信息，现在让你写一个创建学生的页面，你的后台应该怎么写呢？首先我们会在前端一个一个罗列出这些字段，让用户去填写，然后我们从后天一个一个接收用户的输入，创建一个新的学生对象，保存其实，重点不是这些，而是合法性验证，我们需要在前端判断用户输入是否合法，比如姓名必须在多少字符以内，电话号码必须是多少位的数字，邮箱必须是邮箱的格式这些当然可以一点一点手动写限制，各种判断，这毫无问题，除了麻烦我们现在有个更优雅（以后在Python相关的内容里，要多用“优雅”这个词，并且养成习惯）的方法：ModelForm先来简单的，生硬的把它用上，再来加验证条件。
</code></pre>

<h3 id="8-1-创建modelform">　　8.1：创建modelform</h3>

<pre><code class="language-python">#首先导入ModelForm

from django.forms import ModelForm
#在视图函数中，定义一个类，比如就叫StudentList，这个类要继承ModelForm，在这个类中再写一个原类Meta（规定写法，并注意首字母是大写的）
#在这个原类中，有以下属性（部分）：

class StudentList(ModelForm):
    class Meta:
        model =Student #对应的Model中的类
        fields = &quot;__all__&quot; #字段，如果是__all__,就是表示列出所有的字段
        exclude = None #排除的字段
        #error_messages用法：
        error_messages = {
        'name':{'required':&quot;用户名不能为空&quot;,},
        'age':{'required':&quot;年龄不能为空&quot;,},
        }
        #widgets用法,比如把输入用户名的input框给为Textarea
        #首先得导入模块
        from django.forms import widgets as wid #因为重名，所以起个别名
        widgets = {
        &quot;name&quot;:wid.Textarea(attrs={&quot;class&quot;:&quot;c1&quot;}) #还可以自定义属性
        }
        #labels，自定义在前端显示的名字
        labels= {
        &quot;name&quot;:&quot;用户名&quot;
        }
</code></pre>

<p>然后在url对应的视图函数中实例化这个类，把这个对象传给前端</p>

<pre><code class="language-python">def student(request):

    if request.method == 'GET':
        student_list = StudentList()
        return render(request,'student.html',{'student_list':student_list})
        
</code></pre>

<pre><code class="language-python">然后前端只需要 {{ student_list.as_p }} 一下，所有的字段就都出来了，可以用as_p显示全部，也可以通过for循环这
student_list，拿到的是一个个input框，现在我们就不用as_p，手动把这些input框搞出来，as_p拿到的页面太丑。
首先 for循环这个student_list，拿到student对象，直接在前端打印这个student，是个input框student.label ，拿到数据库中每个字段的verbose_name ,如果没有设置这个属性，拿到的默认就是字段名，还可以通过student.errors.0 拿到错误信息有了这些，我们就可以通过bootstrap，自己拼出来想要的样式了，比如：
</code></pre>

<pre><code class="language-python">&lt;body&gt;
&lt;div class=&quot;container&quot;&gt;
    &lt;h1&gt;student&lt;/h1&gt;
    &lt;form method=&quot;POST&quot; novalidate&gt;
        {% csrf_token %}
        {# {{ student_list.as_p }}#}
        {% for student in student_list %}
            &lt;div class=&quot;form-group col-md-6&quot;&gt;
                {# 拿到数据字段的verbose_name,没有就默认显示字段名 #}
                &lt;label class=&quot;col-md-3 control-label&quot;&gt;{{ student.label }}&lt;/label&gt;
                &lt;div class=&quot;col-md-9&quot; style=&quot;position: relative;&quot;&gt;{{ student }}&lt;/div&gt;
            &lt;/div&gt;
        {% endfor %}
        &lt;div class=&quot;col-md-2 col-md-offset-10&quot;&gt;
            &lt;input type=&quot;submit&quot; value=&quot;提交&quot; class=&quot;btn-primary&quot;&gt;
        &lt;/div&gt;
    &lt;/form&gt;
&lt;/div&gt;
&lt;/body&gt;
</code></pre>

<p>现在还缺一个input框的form-contral样式，可以考虑在后台的widget里面添加
比如这样：</p>

<pre><code class="language-python">from django.forms import widgets as wid #因为重名，所以起个别名
widgets = {
&quot;name&quot;:wid.TextInput(attrs={'class':'form-control'}),
&quot;age&quot;:wid.NumberInput(attrs={'class':'form-control'}),
&quot;email&quot;:wid.EmailInput(attrs={'class':'form-control'})
}
</code></pre>

<p>当然也可以在js中，找到所有的input框，加上这个样式，也行。</p>

<p><br/></p>

<h3 id="8-2-添加纪录">　　8.2：添加纪录</h3>

<p>保存数据的时候，不用挨个取数据了，只需要save一下</p>

<pre><code class="language-python">def student(request):

    if request.method == 'GET':
         student_list = StudentList()
         return render(request,'student.html',{'student_list':student_list})
    else:
         student_list = StudentList(request.POST)
         if student_list.is_valid():
         student_list.save()
         return redirect(request,'student_list.html',{'student_list':student_list})
</code></pre>

<p><br/></p>

<h3 id="8-3-编辑数据">　　8.3：编辑数据</h3>

<p>如果不用ModelForm，编辑的时候得显示之前的数据吧，还得挨个取一遍值，如果ModelForm，只需要加一个instance=obj（obj是要修改的数据库的一条数据的对象）就可以得到同样的效果
保存的时候要注意，一定要注意有这个对象（instance=obj），否则不知道更新哪一个数据
代码示例：</p>

<pre><code class="language-python">from django.shortcuts import render,HttpResponse,redirect
from django.forms import ModelForm
# Create your views here.
from app01 import models
def test(request):
    # model_form = models.Student
    model_form = models.Student.objects.all()
    return render(request,'test.html',{'model_form':model_form})

class StudentList(ModelForm):
    class Meta:
        model = models.Student #对应的Model中的类
        fields = &quot;__all__&quot; #字段，如果是__all__,就是表示列出所有的字段
        exclude = None #排除的字段
        labels = None #提示信息
        help_texts = None #帮助提示信息
        widgets = None #自定义插件
        error_messages = None #自定义错误信息
        #error_messages用法：
        error_messages = {
        'name':{'required':&quot;用户名不能为空&quot;,},
        'age':{'required':&quot;年龄不能为空&quot;,},
        }
        #widgets用法,比如把输入用户名的input框给为Textarea
        #首先得导入模块
        from django.forms import widgets as wid #因为重名，所以起个别名
        widgets = {
        &quot;name&quot;:wid.Textarea
        }
        #labels，自定义在前端显示的名字
        labels= {
        &quot;name&quot;:&quot;用户名&quot;
        }
def student(request):
    if request.method == 'GET':
        student_list = StudentList()
        return render(request,'student.html',{'student_list':student_list})
    else:
        student_list = StudentList(request.POST)
        if student_list.is_valid():
            student_list.save()
            return render(request,'student.html',{'student_list':student_list})

def student_edit(request,pk):
    obj = models.Student.objects.filter(pk=pk).first()
    if not obj:
        return redirect('test')
    if request.method == &quot;GET&quot;:
        student_list = StudentList(instance=obj)
        return render(request,'student_edit.html',{'student_list':student_list})
    else:
        student_list = StudentList(request.POST,instance=obj)
        if student_list.is_valid():
            student_list.save()
            return render(request,'student_edit.html',{'student_list':student_list})
</code></pre>

<p>总结： 从上边可以看到ModelForm用起来是非常方便的，比如增加修改之类的操作。但是也带来额外不好的地方，model和form之间耦合了。如果不耦合的话，mf.save()方法也无法直接提交保存。 但是耦合的话使用场景通常局限用于小程序，写大程序就最好不用了。</p>

                        </div>

                        


                        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/post/django%E4%B8%AD%E9%97%B4%E4%BB%B6/">Django中间件</a></li>
        
    </ul>
</div>


                        <div class="post-meta meta-tags">
                            
                            没有标签
                            
                        </div>
                    </article>
                    
    

    
    
                </div>
            </div>
            <div id="secondary">
    <section class="widget">
        <form id="search" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="http://yifan-x.github.io">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="http://yifan-x.github.io/post/django%E4%B8%AD%E9%97%B4%E4%BB%B6/" title="Django中间件">Django中间件</a>
    </li>
    
    <li>
        <a href="http://yifan-x.github.io/post/django-form%E5%92%8Cmodelform%E7%BB%84%E4%BB%B6/" title="Form和ModelForm组件">Form和ModelForm组件</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">分类</h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title">标签</h3>
<div class="tagcloud">
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="http://yifan-x.github.io/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
        </div>
    </div>
</div>
<footer id="footer">
    <div class="container">
        &copy; 2019 <a href="http://yifan-x.github.io">王一帆的博客 By 王一帆</a>.
        Powered by <a rel="nofollow noreferer noopener" href="https://gohugo.io" target="_blank">Hugo</a>.
        <a href="https://www.flysnow.org/" target="_blank">Theme</a> based on <a href="https://github.com/rujews/maupassant-hugo" target="_blank">maupassant</a>.
        
    </div>
</footer>


    
    <script type="text/javascript">
        
        (function () {
            $("pre code").parent().addClass("line-numbers")
        }());

        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script type="text/javascript" src="/js/prism.js" async="true"></script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>


<a id="rocket" href="#top"></a>
<script type="text/javascript" src="/js/totop.js?v=0.0.0" async=""></script>






</body>
</html>
